//Copyright (C) 2014 by Manuel Then, Moritz Kaufmann, Fernando Chirigati, Tuan-Anh Hoang-Vu, Kien Pham, Alfons Kemper, Huy T. Vo
//
//Code must not be used, distributed, without written consent by the authors
#include "head/naive.hpp"
#include "head/TraceStats.hpp"
#include <vector>
#include <algorithm>
#include <cstring>
namespace Query4 {

template<typename bit_t, uint64_t width>
struct BatchBit {
	static const size_t TYPE_BITS_COUNT = sizeof(bit_t) * 8;
	bit_t data[width];

	BatchBit() : data() {
	}
	void negate() {
		for (unsigned i = 0; i < width; ++i) {
			data[i] = ~data[i];
		}
	}

	void setBit(const size_t ix) {
		auto field = ix / TYPE_BITS_COUNT;
		auto field_bit = ix - (field*TYPE_BITS_COUNT);
		data[field] |= BitBaseOp<bit_t>::getSetMask(field_bit);
	}

	bool notZero() {
		bool not_0 = false;
		for (int i = 0; i < width; i++) {
			if (BitBaseOp<bit_t>::notZero(data[i]))
				not_0 = true;
		}
		return not_0;
	}
};

template<typename bit_type>
struct Queueele {
	//uint32_t distance;
	PersonId perId;
	bit_type change;
	Queueele(PersonId perId, bit_type change) : perId(perId), change(change) { };
	Queueele() :perId(), change(){ };
};

void __attribute__ ((noinline)) BFSRunner::run(const PersonId start, const PersonSubgraph& subgraph, BatchBFSdata& bfsData
   #ifdef STATISTICS
   , BatchStatistics&/* statistics */
   #endif
   ) {
	std::cout << "start" << std::endl;
	const auto subgraphSize = subgraph.size();
	const auto sourcePer = bfsData.person;
	BatchBit<BITYPE, BITYPE_WIDTH>* verstatus;
	//verstatus = new BatchBit<BITYPE, BITYPE_WIDTH>[subgraphSize]();
	const auto ret = posix_memalign(reinterpret_cast<void**>(&verstatus), 64, sizeof(BatchBit<BITYPE, BITYPE_WIDTH>)*subgraphSize);//数据对齐（分配内存首地址，对齐边界，指定分配字节大小）
	if (unlikely(ret != 0)) {
		std::cout << "unlikely" << std::endl;
		throw - 1;
	}
	new(verstatus) BatchBit<BITYPE, BITYPE_WIDTH>[subgraphSize]();

	size_t maxqueue = 10000000;
	awfy::FixedSizeQueue<Queueele<BatchBit<BITYPE, BITYPE_WIDTH>>> Change_Q = awfy::FixedSizeQueue<Queueele<BatchBit<BITYPE, BITYPE_WIDTH>>>(maxqueue);

	awfy::FixedSizeQueue<PersonId> BFS_Queue = awfy::FixedSizeQueue<PersonId>(maxqueue);
	awfy::FixedSizeQueue<PersonId> next_BFS_Queue = awfy::FixedSizeQueue<PersonId>(maxqueue);

	BFS_Queue.push_back_pos() = sourcePer;
	verstatus[sourcePer].negate();
	//size_t maxQ = 0;
	//PersonId minPerson = std::numeric_limits<PersonId>::max();


	uint32_t maxvec = subgraphSize;
	//vector<PersonId> VectorPer;
	//vector<PersonId> next_VectorPer;
	//VectorPer.reserve(maxvec);
	//VectorPer.push_back(sourcePer);
	//next_VectorPer.reserve(maxvec);
	
	uint32_t vec_flag[maxvec];
	uint32_t next_vec_flag[maxvec];
	vec_flag[sourcePer] = 1;

	uint32_t cur_vector = 0;
	uint32_t nextDistance = 1;
	uint32_t cur_queue = 0;
	std::cout << "start2" << std::endl;
	while(true){
		//std::cout << nextDistance << std::endl;
		size_t startTime = tschrono::now();

		auto& bfs_queue = cur_queue == 0 ? BFS_Queue : next_BFS_Queue;
		auto& next_bfs_queue = cur_queue == 1 ? BFS_Queue : next_BFS_Queue;
		//auto& vectorper = cur_vector == 0 ? VectorPer : next_VectorPer;
		//auto& next_vectorper = cur_vector == 1 ? VectorPer : next_VectorPer;
		auto& VEC_flag = cur_vector == 0 ? vec_flag : next_vec_flag;
		auto& next_VEC_flag = cur_vector == 1 ? vec_flag : next_vec_flag;


		for (; !Change_Q.empty(); Change_Q.pop_front()) {
			Queueele<BatchBit<BITYPE, BITYPE_WIDTH>> change_ele = Change_Q.front();
			for (int ptr = 0; ptr < BITYPE_WIDTH; ptr++) {
				//std::cout << "change" << std::endl;
				verstatus[change_ele.perId].data[ptr] |= change_ele.change.data[ptr];
			}
		}
		Change_Q.reset(maxqueue);

		/*for (int ii = 0; ii < subgraphSize; ii++) {
			std::bitset<8> bis(verstatus[ii].data[0]);
			std::bitset<8> bis1(verstatus[ii].data[1]);
			std::cout << bis << " " << bis1 << std::endl;
		}
		std::cout << std::endl;*/
		
		

		while (!bfs_queue.empty()) {

			PersonId curPerson = bfs_queue.front();
			bfs_queue.pop_front();
			const auto& curFriendsedges = *subgraph.retrieveedges(curPerson);
			auto friendsedgesBounds = curFriendsedges.bounds();
			const auto& curFriends = *subgraph.retrieve(curPerson);
			auto friendsBounds = curFriends.bounds();

			while (friendsBounds.first != friendsBounds.second && friendsedgesBounds.first != friendsedgesBounds.second) {
				//PersonId curfriend = *friendsBounds.first;
				BatchBit<BITYPE, BITYPE_WIDTH> D;
				//vector<PersonId>::iterator result = find(vectorper.begin(), vectorper.end(), *friendsBounds.first);
				
				if (VEC_flag[*friendsBounds.first]>0) {//处理冲突
					
					bool insert = false;
					for (int s = 0; s < BITYPE_WIDTH; s++) {
						D.data[s] = verstatus[curPerson].data[s] & friendsedgesBounds.first->data[s] & ~verstatus[*friendsBounds.first].data[s];
						if (BitBaseOp<BITYPE>::notZero(D.data[s])) {
							//std::cout << "cruch in distance = "<< nextDistance << std::endl;
							insert = true;
							uint64_t numofone = BitBaseOp<BITYPE>::NumOfOne(D.data[s]);
							bfsData.totalDistances += numofone * nextDistance;
							bfsData.totalReachable += numofone;
						}
					}
					if (insert) {
						Change_Q.push_back_pos() = Queueele<BatchBit<BITYPE, BITYPE_WIDTH>>(*friendsBounds.first, D);
						//vector<PersonId>::iterator resu_ = find(next_vectorper.begin(), next_vectorper.end(), *friendsBounds.first);
						if (next_VEC_flag[*friendsBounds.first]>0) {
							next_bfs_queue.push_back_pos() = *friendsBounds.first;
							next_VEC_flag[*friendsBounds.first]++;
						}
					}
				}
				else {//无冲突
					//std::cout << "no cruch in distance = " << nextDistance << std::endl;
					bool insert = false;
					for (int s = 0; s < BITYPE_WIDTH; s++) {
						D.data[s] = verstatus[curPerson].data[s] & friendsedgesBounds.first->data[s] & ~verstatus[*friendsBounds.first].data[s];
						if (BitBaseOp<BITYPE>::notZero(D.data[s])) {
							verstatus[*friendsBounds.first].data[s] |= D.data[s];
							insert = true;
							uint64_t numofone = BitBaseOp<BITYPE>::NumOfOne(D.data[s]);
							bfsData.totalDistances += numofone * nextDistance;
							bfsData.totalReachable += numofone;
						}
					}
					if (insert) {
						next_bfs_queue.push_back_pos() = *friendsBounds.first;
						next_VEC_flag[*friendsBounds.first]++;
					}
				}
				friendsBounds.first++;
				friendsedgesBounds.first++;
			}
		}
		
		TraceStats<TYPE_BITS*WIDTH>& stats = TraceStats<TYPE_BITS*WIDTH>::getStats();
		stats.traceRound(nextDistance);
		stats.addRoundDuration(nextDistance, (tschrono::now() - startTime));

		//std::cout << nextDistance << "\t bfsq=" << bfs_queue.size() <<"\t nexbfsq="<< next_bfs_queue.size()<<  "\t chaq="<<Change_Q.size() <<"\t\t vec="<< vectorper.size()<< "\t nextvec=" << next_vectorper.size() << std::endl;

		if (next_bfs_queue.empty() && Change_Q.empty())
			break;

		cur_queue = 1 - cur_queue;
		//vectorper.clear();
		memset(VEC_flag, 0, subgraphSize * sizeof(uint32_t));

		cur_vector = 1 - cur_vector;
		nextDistance++;
	}
	free(verstatus);
	std::cout << "after free" << std::endl;
   /*BFSQueue& toVisit = getThreadLocalPersonVisitQueue(subgraph.size());
   assert(toVisit.empty()); //Data structures are in a sane state

   // Initialize BFS
   Distance* seen = new Distance[subgraph.size()]();
   seen[start] = 1; // Level = distance + 1, Level 0 = not seen
   toVisit.push_back_pos() = start;

   // Run rounds until we can either early exit or have reached all nodes
   Distance distance=0;
   do {
      size_t startTime = tschrono::now();

      const Persons personsRemaining=(bfsData.componentSize-1)-bfsData.totalReachable;//剩余的顶点数
      Persons numDiscovered = runRound(subgraph, seen, toVisit, toVisit.size(), personsRemaining);
      assert(distance<std::numeric_limits<Distance>::max());
      distance++;

      // Adjust result
      bfsData.totalReachable+=numDiscovered;
      bfsData.totalDistances+=numDiscovered*distance;

      TraceStats<TYPE_BITS*WIDTH>& stats = TraceStats<TYPE_BITS*WIDTH>::getStats();
      stats.traceRound(distance);
      stats.addRoundDuration(distance, (tschrono::now()-startTime));

      // Exit criteria for full BFS
      if((bfsData.componentSize-1)==bfsData.totalReachable) {
         break;
      }
   } while(true);

   delete[] seen;*/
}


//Persons numDiscovered = runRound(subgraph, seen, toVisit, toVisit.size(), personsRemaining);
// XXX: __attribute__((optimize("align-loops")))  this crashed the compiler
Persons __attribute__((hot)) BFSRunner::runRound(const PersonSubgraph& subgraph, Distance* __restrict__ seen, BFSQueue& toVisit, const Persons numToVisit, const Persons numUnseen) {
   Persons numRemainingToVisit=numToVisit;
   Persons numRemainingUnseen=numUnseen;

   do {
      assert(!toVisit.empty());

      const PersonId person = toVisit.front();
      toVisit.pop_front();

      // Iterate over friends
      auto friendsBounds = subgraph.retrieve(person)->bounds();
      while(friendsBounds.first != friendsBounds.second) {
         if (seen[*friendsBounds.first]) {
            ++friendsBounds.first;
            continue;
         }
         toVisit.push_back_pos() = *friendsBounds.first;

         seen[*friendsBounds.first] = true;
         ++friendsBounds.first;
         numRemainingUnseen--;
      }

      numRemainingToVisit--;
   } while(numRemainingToVisit>0 && numRemainingUnseen>0);

   return numUnseen-numRemainingUnseen;
}

}