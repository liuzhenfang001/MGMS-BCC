//Copyright (C) 2014 by Manuel Then, Moritz Kaufmann, Fernando Chirigati, Tuan-Anh Hoang-Vu, Kien Pham, Alfons Kemper, Huy T. Vo
//
//Code must not be used, distributed, without written consent by the authors
#pragma once
#include"GraphFromFile.hpp"
#include "log.hpp"
#include "queue.hpp"
#include <iostream>
#include <cstdint>
#include <cstddef>
#include <cassert>
#include <utility>
#include <vector>
#include <string>
#include <limits>
#include <unordered_map>
#include <cstdlib>
#include <ctime>
#include "bitops.hpp"
#include "sse.hpp"
#include <bitset>
#include <immintrin.h>
#include <emmintrin.h>
#include <smmintrin.h>
#include <random>
#include <algorithm>
//#include "query4.hpp"
#define BITYPE int64_t
#define BITYPE_WIDTH 16

/*struct NodePair {
   uint64_t idA;		//uint64_t是long long类型
   uint64_t idB;

   NodePair() { }
   NodePair(uint64_t idA, uint64_t idB)
      : idA(idA), idB(idB)
   { }
};*/

struct GraphData {
   size_t numNodes;			//顶点数
   std::vector<NodePair> edges;//<0,100><0,104><1,233><1,999><2,3>...<100,0><104,0>...此处是伪id
   std::unordered_map<uint64_t,uint64_t> revNodeRenaming;//<0,v1><1,v2><2,v3>...此处记录伪id对应的真实id
   GraphData(const size_t numNodes, std::vector<NodePair> edges, std::unordered_map<uint64_t,uint64_t> revNodeRenaming)
      : numNodes(numNodes), edges(move(edges)), revNodeRenaming(std::move(revNodeRenaming)){
   }

   GraphData(GraphData& other) = delete;
   GraphData(GraphData&& other) = default;

   static GraphData loadFromPath(const std::vector<NodePair>& GraphEdges, const std::vector<float>& GraphWeight);
   static GraphData sampledata(const std::vector<NodePair>& GraphEdges, const std::vector<float>& GraphWeight);
   //static std::vector<NodePair> loadComponent(const std::string& edgesFile);
   static void quick_sort(std::vector<NodePair>& edges, std::vector<float>& pro, int l, int r);
};

template<class EntryType>
class SizedList {
public:
   typedef EntryType Size;
   typedef EntryType Entry;

private:
   Size count;

public:
   SizedList() {
   }

   /// Reads the size for the list at the pointer position
   inline const Size& size() const {
      return count;
   }

   inline Size& size() {
      return count;
   }

   /// Sets the size for the list at the pointer position
   void setSize(const Size count) {
      this->count = count;
   }

   const Entry* getPtr(const size_t index) const __attribute__ ((pure)) {
      const auto offsetPtr = reinterpret_cast<const uint8_t*>(this) + sizeof(Size) + sizeof(Entry)*index;
      return reinterpret_cast<const Entry*>(offsetPtr);
   }

   Entry* getPtr(const size_t index) __attribute__ ((pure)) {
      const auto offsetPtr = reinterpret_cast<uint8_t*>(this) + sizeof(Size) + sizeof(Entry)*index;
      return reinterpret_cast<Entry*>(offsetPtr);
   }

   std::pair<const Entry*,const Entry* const> bounds() const __attribute__ ((pure)) {
      const Entry* i=getPtr(0);
      return std::make_pair(i,i+count);
   }

   SizedList<Entry>* nextList(Size count) __attribute__ ((pure)) {
      auto offsetPtr = reinterpret_cast<uint8_t*>(this)+sizeof(Size)+sizeof(Entry)*count;
      return reinterpret_cast<SizedList<Entry>*>(offsetPtr);
   }
};



template<class EntryType>
class EdgesList {
public:
	typedef uint32_t Size;
	typedef EntryType Entry;

private:
	Size count;

public:
	EdgesList() {
	}

	/// Reads the size for the list at the pointer position
	inline const Size& size() const {
		return count;
	}

	inline Size& size() {
		return count;
	}

	/// Sets the size for the list at the pointer position
	void setSize(const Size count) {
		this->count = count;
	}

	const Entry* getPtr(const size_t index) const __attribute__((pure)) {
		
		const auto offsetPtr = reinterpret_cast<const uint8_t*>(this) + sizeof(Size) + sizeof(Entry)*index;
		return reinterpret_cast<const Entry*>(offsetPtr);
	}

	Entry* getPtr(const size_t index) __attribute__((pure)) {
		const auto offsetPtr = reinterpret_cast<uint8_t*>(this) + sizeof(Size) + sizeof(Entry)*index;
		return reinterpret_cast<Entry*>(offsetPtr);
	}

	std::pair<const Entry*, const Entry* const> bounds() const __attribute__((pure)) {
		const Entry* i = getPtr(0);
		return std::make_pair(i, i + count);
	}

	EdgesList<Entry>* nextList(Size count) __attribute__((pure)) {
		auto offsetPtr = reinterpret_cast<uint8_t*>(this) + sizeof(Size) + sizeof(Entry)*count;
		return reinterpret_cast<EdgesList<Entry>*>(offsetPtr);
	}
};

template<typename bit_t, uint64_t width>
struct EdgesBits {
	static const size_t TYPE_BITS_COUNT = sizeof(bit_t) * 8 ;

	bit_t data[width];

	EdgesBits():data(){
		/*for (int i = 0; i < width; i++) {
			data[i] = BitBaseOp<bit_t>::zero();
			
		}*/
		
	}

	void getedges(float p) {
		int insert_num = 0;
		int insert_type = 0;
		if (p < 0.5) {
			insert_num = p * TYPE_BITS_COUNT*width;
			insert_type = 1;
		}
		else {
			insert_num = (1 - p) * TYPE_BITS_COUNT*width;
			insert_type = 0;
		}
		std::random_device rd;
		std::mt19937 mt(rd());
		std::uniform_int_distribution<> dis(1, TYPE_BITS_COUNT*width);
		//EdgesBits<bit_t,width> edge;
		if (insert_type==1) {
			for (int i = 0; i < insert_num; i++) {
				int pos = dis(mt) - 1;
				auto field = pos / TYPE_BITS_COUNT;
				auto field_bit = pos - (field*TYPE_BITS_COUNT);
				data[field] |= BitBaseOp<bit_t>::getSetMask(field_bit);
			}

		}
		else {
			for (int i = 0; i < insert_num; i++) {
				int pos = dis(mt) - 1;
				auto field = pos / TYPE_BITS_COUNT;
				auto field_bit = pos - (field*TYPE_BITS_COUNT);
				data[field] |= BitBaseOp<bit_t>::getSetMask(field_bit);
			}
			
			for (int j = 0; j < width; j++) {
				data[j] = ~data[j];
			}
		}
	}
}__attribute__((aligned(1)));

template<class IdType>
class Graph {
public:
   typedef IdType Id;
   typedef SizedList<Id>* Content;
   typedef EdgesList<EdgesBits<BITYPE,BITYPE_WIDTH>>* EdgesContent;
   typedef uint32_t ComponentId;//连通分量？？
   typedef uint64_t ComponentSize;

   const size_t numVertices;
   size_t numEdges;
   //std::vector<float> edges_prob;
   std::vector<ComponentId> personComponents;//记录每个顶点对应的联通分量id
   std::vector<ComponentSize> componentSizes;//连通分量个数
   std::vector<ComponentSize> componentEdgeCount;//
   ComponentSize maxComponentSize;
   
private:
   EdgesContent* edgesbit;
   Content* table;
   //EdgesBits<BITYPE,BITYPE_WIDTH>** edgesbit;
   std::unordered_map<uint64_t,uint64_t> revNodeRenaming;

public:
   uint8_t* data;
   uint8_t* edgesdata;
   //构造函数，为personComponents分配numVertices个大小空间，每个为0
   Graph(size_t numVertices) : numVertices(numVertices), personComponents(numVertices), componentSizes(), componentEdgeCount(), maxComponentSize(), table(nullptr), data(nullptr),edgesdata(nullptr), edgesbit(nullptr){
      // XXX: Maybe posix_memalign helps?
      table = new Content[numVertices]();
	  edgesbit = new EdgesContent[numVertices]();

   }

   Graph(Graph& other) = delete;

   Graph(Graph&& other) : numVertices(other.numVertices), numEdges(other.numEdges), personComponents(other.personComponents), componentSizes(other.componentSizes), componentEdgeCount(other.componentEdgeCount), maxComponentSize(other.maxComponentSize), table(other.table), revNodeRenaming(std::move(other.revNodeRenaming)), data(other.data),edgesbit(other.edgesbit),edgesdata(other.edgesdata) {
      other.table=nullptr;
      other.data=nullptr;
	  other.edgesbit = nullptr;
	  other.edgesdata = nullptr;
   }

   ~Graph() {
      if(table) {
         delete[] table;
         table = nullptr;
      }

      if(data) {
         delete[] data;
         data = nullptr;
      }

	  if (edgesbit) {
		  delete[] edgesbit;
		  edgesbit = nullptr;
	  }

	  if (edgesdata) {
		  delete[] edgesdata;
		  edgesdata = nullptr;
	  }
   }

   IdType mapInternalNodeId(IdType id) const {
      const auto iter = revNodeRenaming.find(id);
      if(iter!=revNodeRenaming.cend()) {
         return iter->second;
      } else {
         throw -1;
      }
   }

   /// Inserts the data for the specified id into the index
   void insert(Id id, Content content) {
      assert(table!=nullptr);
      assert(id<numVertices);
      table[id] = std::move(content);
   }

   void insertedges(Id id, EdgesContent content) {
	   assert(edgesbit != nullptr);
	   assert(id < numVertices);
	   edgesbit[id] = std::move(content);
   }


   /// Retrieves the data for the specified id
   __attribute__ ((pure)) Content retrieve(Id id) const {
      assert(id<numVertices);
      assert(table[id]!=nullptr);
      return table[id];
   }

   __attribute__((pure)) EdgesContent retrieveedges(Id id) const {
	   assert(id < numVertices);
	   assert(edgesbit[id] != nullptr);
	   return edgesbit[id];
   }

   /*__attribute__((pure)) BITYPE findedges(Id id, int friendId, uint32_t width) const{
	   return edgesbit[id][friendId].data[width];
   }*/

   static BITYPE getedges() {
	   std::random_device rd;
	   std::mt19937 mt(rd());
	   BITYPE edge=0;
	   for (int i = 0; i < sizeof(BITYPE)*8; i++) {
		   std::random_device rd1;
		   std::mt19937 mt1(rd1());
		   //std::cout << mt1() << " " << mt() << std::endl;
		   if (mt1() < mt()) {
			   edge |= BitBaseOp<BITYPE>::getSetMask(i);
		   }
	   }
	   return edge;
   }

   inline IdType maxKey() const {
      return numVertices-1;
   }

   inline IdType size() const {
      return numVertices;
   }

   /*static Graph sampleGraph(const std::string& edgesFile) {//根据graphdata生成persongraph，table包含了邻居节点
	   GraphData graphData = GraphData::sampledata(edgesFile, true);
	   IdType numPersons = graphData.numNodes;//顶点数
	   std::vector<NodePair>& edges = graphData.edges;//边
	   Graph personGraph(numPersons);
	   personGraph.edges_prob = std::move(graphData.prob);
	   personGraph.revNodeRenaming = std::move(graphData.revNodeRenaming);

	   std::vector<NodePair> double_edges;//双向边用于划分连通分量
	   double_edges.reserve(edges.size() * 2);
	   for (NodePair& a : edges) {
		   double_edges.push_back(a);
		   double_edges.push_back(NodePair(a.idB, a.idA));
	   }
	   std::sort(double_edges.begin(), double_edges.end(), [](const NodePair& a, const NodePair& b) {//Lambda
		   return a.idA < b.idA || (a.idA == b.idA && a.idB < b.idB);
	   });
	   std::vector<NodePair> uniqueEdges(double_edges.size());
	   size_t e = 0;
	   NodePair last(std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max());
	   for (const NodePair& a : double_edges) {
		   if (last.idA != a.idA || last.idB != a.idB) {
			   last = a;
			   uniqueEdges[e++] = NodePair(a.idA, a.idB);
		   }
	   }
	   uniqueEdges.resize(e);

	   const size_t dataSize = (numPersons + edges.size()) * sizeof(IdType);
	   uint8_t* data = new uint8_t[dataSize]();
	   {//为personGraph的每个点添加邻居
		   SizedList<IdType>* neighbours = reinterpret_cast<SizedList<IdType>*>(data);
		   size_t ix = 0;
		   for (IdType person = 0; person < numPersons; person++) {
			   assert(reinterpret_cast<uint8_t*>(neighbours) < data + dataSize);
			   IdType* insertPtr = neighbours->getPtr(0);
			   IdType count = 0;
			   while (ix < edges.size() && edges[ix].idA == person) {
				   *insertPtr = edges[ix].idB;
				   insertPtr++;
				   count++;
				   ix++;
			   }

			   neighbours->setSize(count);
			   personGraph.insert(person, neighbours);
			   neighbours = neighbours->nextList(count);
		   }
	   }

	   personGraph.data = data;
	   personGraph.numEdges = edges.size();

	   LOG_PRINT("[LOADING] Created person graph of size: " << dataSize / 1024 << " kb");

	   //Graph tempGraph = Graph<IdType>::loadFromPath(edgesFile);
	   //personGraph.componentSizes = std::move(tempGraph.componentSizes);
	   //personGraph.componentEdgeCount = std::move(tempGraph.componentEdgeCount);
	   //personGraph.personComponents = std::move(tempGraph.personComponents);
	   //personGraph.maxComponentSize = tempGraph.maxComponentSize;
	   
	   personGraph.analyzeGraph(double_edges);
	   
	   return std::move(personGraph);
   }*/

   static Graph sampleGraph(const std::vector<NodePair>& GraphEdges,const std::vector<float>& GraphWeight) {//根据graphdata生成persongraph，table包含了邻居节点
	   GraphData graphData = GraphData::sampledata(GraphEdges, GraphWeight);
	   IdType numPersons = graphData.numNodes;//顶点数
	   std::vector<NodePair>& edges = graphData.edges;//边
	   Graph personGraph(numPersons);
	   //personGraph.edges_prob = std::move(graphData.prob);
	   personGraph.revNodeRenaming = std::move(graphData.revNodeRenaming);

	   std::vector<NodePair> double_edges;//双向边用于划分连通分量
	   double_edges.reserve(edges.size() * 2);
	   for (NodePair& a : edges) {
		   double_edges.push_back(a);
		   double_edges.push_back(NodePair(a.idB, a.idA));
	   }
	   std::sort(double_edges.begin(), double_edges.end(), [](const NodePair& a, const NodePair& b) {//Lambda
		   return a.idA < b.idA || (a.idA == b.idA && a.idB < b.idB);
	   });
	   std::vector<NodePair> uniqueEdges(double_edges.size());
	   size_t e = 0;
	   std::vector<size_t> index;
	   NodePair last(std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max());
	   for (const NodePair& a : double_edges) {
		   if (last.idA != a.idA) {
			   index.push_back(e);
			   last = a;
			   uniqueEdges[e++] = NodePair(a.idA, a.idB);
		   }
		   else if (last.idB != a.idB) {
			   last = a;
			   uniqueEdges[e++] = NodePair(a.idA, a.idB);
		   }
	   }
	   uniqueEdges.resize(e);
	   index.push_back(e);
	   const size_t dataSize = (numPersons + edges.size()) * sizeof(IdType);
	   std::cout << "start sample one graph" << std::endl;
	   uint8_t* data = new uint8_t[dataSize]();
	   {//为personGraph的每个点添加邻居
		   SizedList<IdType>* neighbours = reinterpret_cast<SizedList<IdType>*>(data);
		   size_t ix = 0;

		   std::random_device rd;
		   std::mt19937 mt(rd());
		   std::uniform_int_distribution<> dis(1, BITYPE_WIDTH * sizeof(BITYPE) * 8);
		   for (IdType person = 0; person < numPersons; person++) {
			   assert(reinterpret_cast<uint8_t*>(neighbours) < data + dataSize);
			   IdType* insertPtr = neighbours->getPtr(0);
			   IdType count = 0;
			   while (ix < edges.size() && edges[ix].idA == person) {
				   int prob = GraphWeight[ix] * BITYPE_WIDTH * sizeof(BITYPE) * 8;
				   if (dis(mt) < prob) {
					   continue;
				   }
				   *insertPtr = edges[ix].idB;
				   insertPtr++;
				   count++;
				   ix++;
			   }

			   neighbours->setSize(count);
			   personGraph.insert(person, neighbours);
			   neighbours = neighbours->nextList(count);
		   }
	   }

	   personGraph.data = data;
	   personGraph.numEdges = edges.size();

	   LOG_PRINT("[LOADING] Created person graph of size: " << dataSize / 1024 << " kb");
	   personGraph.analyzeGraph(uniqueEdges,index);

	   return std::move(personGraph);
   }

   /*static Graph loadFromPath(const std::string& edgesFile) {//根据graphdata生成persongraph，table包含了邻居节点
      GraphData graphData = GraphData::loadFromPath(edgesFile);
      IdType numPersons = graphData.numNodes;//顶点数
      std::vector<NodePair>& edges = graphData.edges;//边
	  //std::cout<<"number of node = " << numPersons << ",and num of edges = " << edges.size()<< std::endl;
      // Build graph
      Graph personGraph(numPersons);
      personGraph.revNodeRenaming = std::move(graphData.revNodeRenaming);
      const size_t dataSize = (numPersons+edges.size())*sizeof(IdType);
      uint8_t* data = new uint8_t[dataSize]();
      {//为personGraph的每个点添加邻居
         SizedList<IdType>* neighbours = reinterpret_cast<SizedList<IdType>*>(data);
         size_t ix=0;
         for(IdType person=0; person<numPersons; person++) {
            assert(reinterpret_cast<uint8_t*>(neighbours)<data+dataSize);
            IdType* insertPtr = neighbours->getPtr(0);
            IdType count=0;
            while(ix<edges.size() && edges[ix].idA==person) {
               *insertPtr = edges[ix].idB;
               insertPtr++;
               count++;
               ix++;
            }

            neighbours->setSize(count);
            personGraph.insert(person, neighbours);
            neighbours = neighbours->nextList(count);
         }
      }

      personGraph.data = data;
      personGraph.numEdges = edges.size();

      //LOG_PRINT("[LOADING] Created person graph of size: "<< dataSize/1024<<" kb");

      #ifdef DEBUG
      uint64_t retrievableFriends = 0;
      for(IdType person=0; person<numPersons; person++) {
         retrievableFriends += personGraph.retrieve(person)->size();
      }
      assert(retrievableFriends==edges.size());
      #endif

      personGraph.analyzeGraph();

      return std::move(personGraph);      
   }*/


   static Graph loadUCGFromPath(const std::vector<NodePair>& GraphEdges, const std::vector<float>& GraphWeight) {//根据graphdata生成persongraph，table包含了邻居节点
	   //LOG_PRINT("LoadUCGFromPath");
	   GraphData graphData = GraphData::loadFromPath(GraphEdges, GraphWeight);
	   //std::vector<NodePair> tempedges = std::move(GraphData::loadComponent(edgesFile))
	   IdType numPersons = graphData.numNodes;//顶点数
	   std::vector<NodePair>& edges = graphData.edges;//边
	   LOG_PRINT("Nodes: " << numPersons);
	   LOG_PRINT("Edges: " << edges.size());
	   std::vector<NodePair> double_edges;
	   double_edges.reserve(edges.size() * 2);
	   for (NodePair& a : edges) {
		   double_edges.push_back(a);
		   double_edges.push_back(NodePair(a.idB, a.idA));
	   }
	   std::sort(double_edges.begin(), double_edges.end(), [](const NodePair& a, const NodePair& b) {//Lambda
		   return a.idA < b.idA || (a.idA == b.idA && a.idB < b.idB);
	   });
	   std::vector<NodePair> uniqueEdges(double_edges.size());
	   size_t e = 0;
	   std::vector<size_t> index;
	   NodePair last(std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max());
	   for (const NodePair& a : double_edges) {
		   if (last.idA != a.idA) {
			   index.push_back(e);
			   last = a;
			   uniqueEdges[e++] = NodePair(a.idA, a.idB);
		   }
		   else if (last.idB != a.idB) {
			   last = a;
			   uniqueEdges[e++] = NodePair(a.idA, a.idB);
		   }
	   }
	   uniqueEdges.resize(e);
	   index.push_back(e);

	  // for (int i = 0; i < 500; i++) {
		   //std::cout << uniqueEdges[i].idA << "--" << uniqueEdges[i].idB <<" "<< index[uniqueEdges[i].idA] << std::endl;
	  // }

	   Graph personGraph(numPersons);
	   //personGraph.edges_prob = std::move(graphData.prob);
	   personGraph.revNodeRenaming = std::move(graphData.revNodeRenaming);
	   const size_t dataSize = (numPersons + edges.size()) * sizeof(IdType);
	   uint8_t* data = new uint8_t[dataSize]();
	   {//为personGraph的每个点添加邻居
		   SizedList<IdType>* neighbours = reinterpret_cast<SizedList<IdType>*>(data);
		   size_t ix = 0;
		   for (IdType person = 0; person < numPersons; person++) {
			   assert(reinterpret_cast<uint8_t*>(neighbours) < data + dataSize);
			   IdType* insertPtr = neighbours->getPtr(0);
			   IdType count = 0;
			   while (ix < edges.size() && edges[ix].idA == person) {
				   *insertPtr = edges[ix].idB;
				   insertPtr++;
				   count++;
				   ix++;
			   }
			   neighbours->setSize(count);
			   personGraph.insert(person, neighbours);
			   neighbours = neighbours->nextList(count);
		   }
	   }
	   const size_t edgesSize = numPersons * sizeof(uint32_t) + edges.size() * sizeof(BITYPE) * BITYPE_WIDTH;
	 
	   
	   //teststruct->data[0] = ~data[0];


	   uint8_t* edgesdata1 = new uint8_t[edgesSize]();
	   {
		   EdgesList<EdgesBits<BITYPE, BITYPE_WIDTH>>* neighboursedges = reinterpret_cast<EdgesList<EdgesBits<BITYPE,BITYPE_WIDTH>>*>(edgesdata1);
		   size_t iy = 0;
		   size_t edgeid = 0;
		   for (IdType person = 0; person < numPersons; person++) {
			   assert(reinterpret_cast<uint8_t*>(neighboursedges) < edgesdata1 + edgesSize);
			   EdgesBits<BITYPE, BITYPE_WIDTH>* insertPtr = reinterpret_cast<EdgesBits<BITYPE, BITYPE_WIDTH>*>(neighboursedges->getPtr(0));
			   IdType count = 0;
			   while (iy < edges.size() && edges[iy].idA == person) {
				   EdgesBits<BITYPE, BITYPE_WIDTH>* test = new EdgesBits<BITYPE, BITYPE_WIDTH>();
				   test->getedges(GraphWeight[edgeid]);

				   //std::cout << BitBaseOp<BITYPE>::popCount(test->data[0]) << std::endl;
				   //new(insertPtr) EdgesBits<BITYPE, BITYPE_WIDTH>();
				   memcpy(reinterpret_cast<void*>(insertPtr), reinterpret_cast<void*>(test), sizeof(BITYPE)*BITYPE_WIDTH);
				   //std::cout << BitBaseOp<BITYPE>::popCount(insertPtr->data[0]) << std::endl;

				   //std::cout << "变量insert的地址: " << static_cast<void *>(insertPtr) << std::endl;
				   /*for (int i = 0; i < BITYPE_WIDTH; i++) {
					   std::cout << "变量data" << i << "的地址: " << &insertPtr->data[i] << std::endl;
				   }*/
				   //std::cout << sizeof(*insertPtr) << std::endl;
				   //insertPtr->getedges(personGraph.edges_prob[edgeid]);
				   insertPtr++;
				   count++;
				   iy++;
				   edgeid++;
			   }
			   neighboursedges->setSize(count);
			   personGraph.insertedges(person, neighboursedges);
			   neighboursedges = neighboursedges->nextList(count);
		   }
	   }

	   personGraph.edgesdata = edgesdata1;
	   personGraph.data = data;
	   personGraph.numEdges = edges.size();

	  /*const auto& curFriendsedges = personGraph.retrieveedges(0);
	   auto friendsedgesBounds = curFriendsedges->bounds();
	   while (friendsedgesBounds.first != friendsedgesBounds.second) {
		   std::cout << (friendsedgesBounds.first) << "address";
		   std::cout << BitBaseOp<BITYPE>::popCount(friendsedgesBounds.first->data[0]) << std::endl;
		   
		   friendsedgesBounds.first++;
	  }*/

	   //LOG_PRINT("[LOADING] Created person graph of size: " << dataSize / 1024 << " kb");
#ifdef DEBUG
	   uint64_t retrievableFriends = 0;
	   for (IdType person = 0; person < numPersons; person++) {
		   retrievableFriends += personGraph.retrieve(person)->size();
	   }
	   assert(retrievableFriends == edges.size());
#endif
	   LOG_PRINT("start analyze");
		personGraph.analyzeGraph(uniqueEdges,index);
		

		//Graph tempGraph = Graph<IdType>::loadFromPath(edgesFile);
		//personGraph.analyzeGraph();
		//personGraph.componentSizes = std::move(tempGraph.componentSizes);
		//personGraph.componentEdgeCount = std::move(tempGraph.componentEdgeCount);
		//personGraph.personComponents = std::move(tempGraph.personComponents);
		//personGraph.maxComponentSize = tempGraph.maxComponentSize;
	   return std::move(personGraph);
   }

private:

	void analyzeUCG() {
		const auto graphSize = size();

		//componentSizes.push_back(std::numeric_limits<ComponentSize>::max()); // Component 0 is invalid
		//componentEdgeCount.push_back(std::numeric_limits<ComponentSize>::max()); // Component 0 is invalid
	
		// Identify connected components by running bfs
		//awfy::FixedSizeQueue<IdType> toVisit = awfy::FixedSizeQueue<IdType>(graphSize);
		int componentid = 0;
		int maxComponentId = 0;
		maxComponentSize = 0;
		for (int i = 0; i < graphSize; i++) {
			if (personComponents[i] == 0) {
				componentid = maxComponentId + 1;
			}
			else {
				continue;
			}
			ComponentSize componentSize = 1;
			std::vector<IdType> novisit;
			const auto curNeighbours = retrieve(i);
			//componentNeighborCount += curNeighbours->size();//记录每个连通分量边的数量(一条边记录两次--正反)
			auto neighbourBounds = curNeighbours->bounds();
			auto secondfirst = neighbourBounds.first;
			while (neighbourBounds.first != neighbourBounds.second) {
				const IdType curNeighbour = *neighbourBounds.first;
				++neighbourBounds.first;
				if (personComponents[curNeighbour] != 0) {
					componentid = personComponents[curNeighbour];
					break;
				}
			}
			personComponents[i] = componentid;
			componentSizes[componentid]++;
			
			while (secondfirst != neighbourBounds.second) {
				if (personComponents[*secondfirst] == 0) {
					personComponents[*secondfirst] = componentid;
					componentSizes[componentid]++;
					const auto neigneig = retrieve(*secondfirst);
					auto neigneigBounds = neigneig->bounds();
					while (neigneigBounds.first != neigneigBounds.second) {
						if (personComponents[*neigneigBounds.first] == 0) {
							novisit.push_back(*neigneigBounds.first);
						}
						neigneigBounds.first++;
						componentEdgeCount[componentid]++;
					}
				}
				secondfirst++;
				componentEdgeCount[componentid]++;
			}
			if (novisit.size() != 0)
				f(novisit, componentid);
			maxComponentId = maxComponentId > componentid ? maxComponentId : componentid;
			maxComponentSize = maxComponentSize > componentSizes[componentid] ? maxComponentSize : componentSizes[componentid];
			
		}

	}

	void f(std::vector<IdType> novisit, int componentid) {
		std::vector<IdType> next_visit;
		//for (int i = 0; i < size(); i++)
			//std::cout << "3333node " << revNodeRenaming[i] << " is comid = " <<personComponents[i] << std::endl;
		//next_visit.reserve(graphSize);
		for (int i = 0; i < novisit.size(); i++) {
			personComponents[novisit[i]] = componentid;
			componentSizes[componentid]++;
			const auto curNeighbours = retrieve(novisit[i]);
			auto neighbourBounds = curNeighbours->bounds();
			auto secondfirst = neighbourBounds.first;
			while (neighbourBounds.first != neighbourBounds.second) {
				if (personComponents[*neighbourBounds.first] == 0)
					next_visit.push_back(*neighbourBounds.first);
				neighbourBounds.first++;
			}
		}
		if(next_visit.size()!=0)
			f(next_visit, componentid);
	}

	void analyzeGraph(std::vector<NodePair>& edges, std::vector<size_t>& index) {//划分连通分量
		const auto graphSize = size();

		componentSizes.push_back(std::numeric_limits<ComponentSize>::max()); // Component 0 is invalid
		componentEdgeCount.push_back(std::numeric_limits<ComponentSize>::max()); // Component 0 is invalid

		// Identify connected components by running bfs
		awfy::FixedSizeQueue<IdType> toVisit = awfy::FixedSizeQueue<IdType>(graphSize);

		size_t trivialComponents = 0;
		ComponentId componentId = 1;//连通分量id，1、2、3...
		for (IdType node = 0; node < graphSize; node++) {
			if (personComponents[node] != 0) { continue; }//personComponents初始化默认值为0

			ComponentSize componentSize = 1;
			personComponents[node] = componentId;
			toVisit.push_back_pos() = node;

			uint64_t componentNeighborCount = 0;

			// Do BFS for one connected component
			do {
				const IdType curNode = toVisit.front();
				toVisit.pop_front();

				
				/*for (const NodePair& a : edges) {
					if (a.idA > curNode)
						break;
					else if (a.idA < curNode)
						continue;
					else {
						if (personComponents[a.idB] != 0)
							continue;
						personComponents[a.idB] = componentId;
						componentSize++;
						toVisit.push_back_pos() = a.idB;
						componentNeighborCount++;
					}
				}*/

				for (int i = index[curNode]; i < index[curNode + 1]; i++) {
					if (personComponents[edges[i].idB] != 0)
						continue;
					personComponents[edges[i].idB] = componentId;
					componentSize++;
					toVisit.push_back_pos() = edges[i].idB;
					componentNeighborCount++;
				}

				/*const auto curNeighbours = retrieve(curNode);
				componentNeighborCount += curNeighbours->size();//记录每个连通分量边的数量(一条边记录两次--正反)
				auto neighbourBounds = curNeighbours->bounds();//<i,j>i是顶点id(0,1,2...)指针，j是顶点邻居数量+i的指针
				while (neighbourBounds.first != neighbourBounds.second) {
					const IdType curNeighbour = *neighbourBounds.first;
					++neighbourBounds.first;
					if (personComponents[curNeighbour] != 0) { continue; }//排除了重复项，比如0和999互为邻居，就不会重复将0插入toVisit
					personComponents[curNeighbour] = componentId;
					componentSize++;
					toVisit.push_back_pos() = curNeighbour;
				}*/
			} while (!toVisit.empty());

			componentEdgeCount.push_back(componentNeighborCount); //记录连通分量对应的边数
			componentSizes.push_back(componentSize);//记录连通分量对应的顶点数
			if (componentSize > maxComponentSize) {//maxComponentSize记录最大的连通分量的顶点数（顶点越多连通分量越大）
				maxComponentSize = componentSize;
			}
			if (componentSize < 5) {
				trivialComponents++;
			}
			else {
				//std::cout << "# C " << componentSize << std::endl;
			}

			componentId++;

			// Check for overflow
			assert(componentId > 0);
		}

		//LOG_PRINT("[Query4] Max component size " << maxComponentSize);
		//std::cout << "# Found number components  " << componentId - 1 << " (" << trivialComponents << " are of size < 5)." << std::endl;
	}

   void analyzeGraph() {//划分连通分量
      const auto graphSize = size();

      componentSizes.push_back(std::numeric_limits<ComponentSize>::max()); // Component 0 is invalid
      componentEdgeCount.push_back(std::numeric_limits<ComponentSize>::max()); // Component 0 is invalid

      // Identify connected components by running bfs
      awfy::FixedSizeQueue<IdType> toVisit = awfy::FixedSizeQueue<IdType>(graphSize);

      size_t trivialComponents=0;
      ComponentId componentId=1;//连通分量id，1、2、3...
      for(IdType node=0; node<graphSize; node++) {
         if(personComponents[node]!=0) { continue; }//personComponents初始化默认值为0

         ComponentSize componentSize=1;
         personComponents[node]=componentId;
         toVisit.push_back_pos()=node;

         uint64_t componentNeighborCount=0;

         // Do BFS for one connected component
         do {
            const IdType curNode = toVisit.front();
            toVisit.pop_front();

            const auto curNeighbours=retrieve(curNode);
            componentNeighborCount += curNeighbours->size();//记录每个连通分量边的数量(一条边记录两次--正反)

            auto neighbourBounds = curNeighbours->bounds();//<i,j>i是顶点id(0,1,2...)指针，j是顶点邻居数量+i的指针
            while(neighbourBounds.first != neighbourBounds.second) {
               const IdType curNeighbour=*neighbourBounds.first;
               ++neighbourBounds.first;
               if (personComponents[curNeighbour]!=0) { continue; }//排除了重复项，比如0和999互为邻居，就不会重复将0插入toVisit
               personComponents[curNeighbour]=componentId;
               componentSize++;
               toVisit.push_back_pos() = curNeighbour;
            }
         } while(!toVisit.empty());

         componentEdgeCount.push_back(componentNeighborCount); //记录连通分量对应的边数
         componentSizes.push_back(componentSize);//记录连通分量对应的顶点数
         if(componentSize>maxComponentSize) {//maxComponentSize记录最大的连通分量的顶点数（顶点越多连通分量越大）
            maxComponentSize = componentSize;
         }
         if(componentSize<5) {
            trivialComponents++;
         } 
         componentId++;

         // Check for overflow
         assert(componentId>0);
      }

	  /*for (int i = 0; i < graphSize; i++) {
		  std::cout << "node " << i << " 's id= " << personComponents[i] << std::endl;
	  }*/

	  //std::cout << "maxComponentSize = " << maxComponentSize << ", num of components = " << componentId - 1 << ", maxComponentSize = " << maxComponentSize << std::endl;
	  //for (int i = 1; i < componentId ; i++) {
		 // std::cout << "componentid " << i << " has " << componentSizes[i] << " nodes" << std::endl;
	  //}

      //LOG_PRINT("[Query4] Max component size "<< maxComponentSize);
      //std::cout<<"# Found number components  "<< componentId-1<<" ("<<trivialComponents<<" are of size < 5)."<<std::endl;
   }
};